/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings2() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings2() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings2,
        week: getWeeklyNoteSettings2,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(
              filename,
              // If format contains week, remove day & month formatting
              format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""),
              false
            );
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote(date) {
      const app = window.app;
      const { vault } = app;
      const moment2 = window.moment;
      const { template, format, folder } = getDailyNoteSettings2();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment2().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = moment2();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings2();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment2 } = window;
      let weekStart = moment2.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getWeeklyNoteSettings2();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings2();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings2,
        week: getWeeklyNoteSettings2,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote;
    exports.getDailyNoteSettings = getDailyNoteSettings2;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings2;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  Activity: () => Activity,
  ActivityTrackerTab: () => ActivityTrackerTab,
  InputModal: () => InputModal,
  default: () => ActivityTracker
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_obsidian_daily_notes_interface = __toESM(require_main());
var ActivityTracker = class extends import_obsidian.Plugin {
  async onload() {
    this.app.workspace.onLayoutReady(async () => {
      this.activityButtons = [];
      this.weeklyStatusBarItem = this.addStatusBarItem();
      this.dailyStatusBarItem = this.addStatusBarItem();
      this.weeklyStatusBarItem.addClass("container");
      this.dailyStatusBarItem.addClass("container");
      await this.loadSettings();
      this.addSettingTab(new ActivityTrackerTab(this.app, this));
      this.createActivities();
      this.app.vault.on("create", async () => {
        this.resetActivites();
      });
      this.app.vault.on("delete", async () => {
        this.resetActivites();
      });
      this.app.vault.on("rename", async () => {
        this.resetActivites();
      });
      this.app.vault.on("modify", async (file) => {
        this.tryUpdateActivityValue(file);
      });
      this.addCommand({
        id: `wgt-start`,
        name: `Attach task to goal`,
        repeatable: false,
        editorCallback: (editor) => {
          let x = this.mouseX;
          let y = this.mouseY;
          const menu = new import_obsidian.Menu();
          if (editor.getLine(editor.getCursor().line).contains("- [ ]") && !editor.getLine(editor.getCursor().line).contains("%%wgt")) {
            this.settings.activities.forEach((element) => {
              menu.addItem(
                (item) => item.setTitle(`${element.emoji}   Attach to ${element.name}`).onClick(() => {
                  if (!this.settings.askForWeight) {
                    editor.setLine(editor.getCursor().line, editor.getLine(editor.getCursor().line) + `%%wgt[${element.name}]{1}wgt%%`);
                  } else {
                    new InputModal(this.app, (result) => {
                      editor.setLine(editor.getCursor().line, editor.getLine(editor.getCursor().line) + `%%wgt[${element.name}]{${result}}wgt%%`);
                    }).open();
                  }
                })
              );
            });
          } else if (editor.getLine(editor.getCursor().line).contains("%%wgt")) {
            menu.addItem(
              (item) => item.setTitle(`This task is already attached to a goal. To unattach the task, remove the %%wgt[...]{...}wgt%%`)
            );
          } else {
            menu.addItem((item) => item.setTitle(`Please make sure there is an unchecked task on the current line before attempting to attach it to a goal`));
          }
          menu.showAtPosition({ x, y });
        }
      });
    });
    document.onmousemove = (event) => {
      this.mouseX = event.clientX;
      this.mouseY = event.clientY;
    };
  }
  async createActivities() {
    const weekFormat = (0, import_obsidian_daily_notes_interface.getWeeklyNoteSettings)().format;
    this.weekFileName = (0, import_obsidian.moment)().format(weekFormat).toString() + ".md";
    let weekFile = this.app.metadataCache.getFirstLinkpathDest(this.weekFileName, "/");
    const dayFormat = (0, import_obsidian_daily_notes_interface.getDailyNoteSettings)().format;
    this.mondayFileName = (0, import_obsidian.moment)().startOf("isoWeek").format(dayFormat).toString() + ".md";
    let mondayFile = this.app.metadataCache.getFirstLinkpathDest(this.mondayFileName, "/");
    this.todayFileName = (0, import_obsidian.moment)().format(dayFormat).toString() + ".md";
    let todayFile = this.app.metadataCache.getFirstLinkpathDest(this.todayFileName, "/");
    this.requireWeek = false;
    this.requireDay = false;
    this.settings.activities.forEach((element) => {
      if (element.frequency == "weekly") {
        this.requireWeek = true;
      } else if (element.frequency == "daily") {
        this.requireDay = true;
      }
    });
    this.settings.activities.forEach(async (a) => {
      if (this.requireWeek && !this.requireDay) {
        if (this.settings.useWeekFile) {
          if (weekFile) {
            await this.createActivity(a.name, a.emoji, parseInt(a.max), a.startColor, a.endColor, weekFile, weekFile);
          } else {
            this.displayErrorMessage(this.weekFileName);
          }
        } else {
          if (mondayFile) {
            await this.createActivity(a.name, a.emoji, parseInt(a.max), a.startColor, a.endColor, mondayFile, mondayFile);
          } else {
            this.displayErrorMessage(this.mondayFileName);
          }
        }
      } else if (this.requireDay && !this.requireWeek) {
        if (todayFile) {
          await this.createActivity(a.name, a.emoji, parseInt(a.max), a.startColor, a.endColor, todayFile, todayFile);
        } else {
          this.displayErrorMessage(this.todayFileName);
        }
      } else if (this.requireDay && this.requireWeek) {
        if (this.settings.useWeekFile) {
          if (weekFile && todayFile) {
            await this.createActivity(a.name, a.emoji, parseInt(a.max), a.startColor, a.endColor, weekFile, todayFile);
          } else {
            if (!weekFile) {
              this.displayErrorMessage(this.weekFileName);
            } else if (!todayFile) {
              this.displayErrorMessage(this.todayFileName);
            }
          }
        } else {
          if (mondayFile && todayFile) {
            await this.createActivity(a.name, a.emoji, parseInt(a.max), a.startColor, a.endColor, mondayFile, todayFile);
          } else {
            if (!mondayFile) {
              this.displayErrorMessage(this.mondayFileName);
            } else if (!todayFile) {
              this.displayErrorMessage(this.todayFileName);
            }
          }
        }
      }
    });
  }
  async displayErrorMessage(fileName) {
    if (this.notice) {
      this.notice.hide();
    }
    let message = `WEEKLY GOAL TRACKER : File [${fileName}] not found. Please create it to start tracking goals`;
    this.notice = new import_obsidian.Notice(message, 0);
  }
  async resetActivites() {
    this.activityButtons.forEach((element) => {
      element.remove();
    });
    if (this.notice != null) {
      console.log("hide");
      this.notice.noticeEl.remove();
    }
    this.activityButtons = [];
    this.weeklyStatusBarItem.remove();
    this.weeklyStatusBarItem = this.addStatusBarItem();
    this.dailyStatusBarItem.remove();
    this.dailyStatusBarItem = this.addStatusBarItem();
    this.createActivities();
  }
  async tryUpdateActivityValue(abstractFile) {
    let thisFile = this.app.metadataCache.getFirstLinkpathDest(abstractFile.name, "/");
    let weeklyFile = this.app.metadataCache.getFirstLinkpathDest(this.settings.useWeekFile ? this.weekFileName : this.mondayFileName, "/");
    let dailyFile = this.app.metadataCache.getFirstLinkpathDest(this.todayFileName, "/");
    if (thisFile) {
      let data = this.app.vault.process(thisFile, (string) => {
        return string;
      });
      let lines = (await data).split("\n");
      lines.forEach(async (element) => {
        if (element.contains(`- [x]`) && element.contains(`%%wgt[`) && !element.contains(`%%wgt@[`) || element.contains(`- [ ]`) && element.contains(`%%wgt@[`)) {
          let metadataValue = "";
          if (element.contains(`%%wgt@[`)) {
            metadataValue = element.substring(
              element.indexOf("%%wgt@[") + 7,
              element.indexOf("]{")
            );
          } else {
            metadataValue = element.substring(
              element.indexOf("%%wgt[") + 6,
              element.indexOf("]{")
            );
          }
          let weight = parseInt(element.substring(
            element.indexOf("]{") + 2,
            element.indexOf("}wgt%%")
          ));
          let chosenFile;
          if (this.getIfActivityIsDailyOrWeekly(metadataValue) == "weekly") {
            if (weeklyFile) {
              chosenFile = weeklyFile;
            } else {
              this.displayErrorMessage(this.settings.useWeekFile ? this.weekFileName : this.mondayFileName);
              return;
            }
          } else if (this.getIfActivityIsDailyOrWeekly(metadataValue) == "daily") {
            if (dailyFile) {
              chosenFile = dailyFile;
            } else {
              this.displayErrorMessage(this.todayFileName);
              return;
            }
          }
          if (chosenFile) {
            let value = await this.getValue(metadataValue, chosenFile, false);
            let int = element.contains(`%%wgt@[`) ? -weight : weight;
            value = `${parseInt(value) + int}`;
            this.app.fileManager.processFrontMatter(chosenFile, (frontmatter) => {
              frontmatter[metadataValue] = parseInt(value);
            });
          }
          if (element.contains(`%%wgt@[`)) {
            let newElement = element.replace(`%%wgt@[${metadataValue}]{${weight}}wgt%%`, `%%wgt[${metadataValue}]{${weight}}wgt%%`);
            this.app.vault.process(thisFile, (data2) => {
              return data2.replace(element, newElement);
            });
          } else {
            let newElement = element.replace(`%%wgt[${metadataValue}]{${weight}}wgt%%`, `%%wgt@[${metadataValue}]{${weight}}wgt%%`);
            console.log(newElement);
            this.app.vault.process(thisFile, (data2) => {
              return data2.replace(element, newElement);
            });
          }
          await new Promise((f) => setTimeout(f, 500));
          this.resetActivites();
          return;
        }
      });
    } else {
      this.displayErrorMessage(abstractFile.name);
    }
  }
  async createActivity(metadataValue, emoji, maxValue, startColor, endColor, weeklyFile, dailyFile) {
    let file = this.getIfActivityIsDailyOrWeekly(metadataValue) == "weekly" ? weeklyFile : dailyFile;
    console.log(this.getIfActivityIsDailyOrWeekly(metadataValue));
    let statusBarButton = this.getIfActivityIsDailyOrWeekly(metadataValue) == "weekly" ? this.weeklyStatusBarItem.createEl("button") : this.dailyStatusBarItem.createEl("button");
    this.activityButtons.push(statusBarButton);
    statusBarButton.addClass(this.getIfActivityIsDailyOrWeekly(metadataValue) == "weekly" ? "weeklyStatusBarButton" : "dailyStatusBarButton");
    statusBarButton.addEventListener("click", async () => {
      let value = await this.getValue(metadataValue, file, true);
      if (statusBarButton.hasClass("active")) {
        generateButtonTextNoBoxes(value);
        statusBarButton.removeClass("active");
      } else {
        generateButtonText(value);
        statusBarButton.addClass("active");
      }
    });
    statusBarButton.addEventListener("contextmenu", async (e) => {
      let value = await this.getValue(metadataValue, file, false);
      if (!statusBarButton.hasClass("active")) {
        return;
      }
      let int = e.shiftKey ? -1 : 1;
      value = `${parseInt(value) + int}`;
      generateButtonText(value);
      this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter[metadataValue] = parseInt(value);
      });
    });
    let generateButtonText = async (textValue) => {
      statusBarButton.setText(emoji + ` ${textValue}/${maxValue} `);
      setCSS(true);
      let loopValue = parseInt(textValue) > maxValue ? parseInt(textValue) : maxValue;
      for (let i = 1; i <= loopValue; i = i + 1) {
        if (i <= parseInt(textValue)) {
          statusBarButton.textContent += `\u25AE`;
        } else {
          statusBarButton.textContent += "\u25AF";
        }
      }
    };
    let generateButtonTextNoBoxes = (textValue) => {
      statusBarButton.setText(emoji + ` ` + (this.settings.hideWhenClosed ? `` : `${textValue}/${maxValue} `));
      if (parseInt(textValue) >= maxValue) {
        setCSS(true);
      } else {
        setCSS(false);
      }
    };
    let setCSS = async (color) => {
      if (color) {
        statusBarButton.style.setProperty("background", `linear-gradient(to right, ${startColor} 0%, ${endColor} 100%)`);
      } else {
        statusBarButton.style.setProperty("background", "var(--text-faint)");
      }
      statusBarButton.style.setProperty("-webkit-background-clip", "text");
      statusBarButton.style.setProperty("background-clip", "text");
      statusBarButton.style.setProperty("-webkit-text-fill-color", "transparent");
      statusBarButton.style.setProperty("overflow", "hidden");
    };
    generateButtonTextNoBoxes(await this.getValue(metadataValue, file, false));
  }
  //used to get the value from the frontmatter
  async getValue(metadataValue, file, addFrontmatter) {
    var _a, _b;
    let data = "0";
    data = (_b = (_a = this.app.metadataCache.getCache(file.path)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[metadataValue];
    if (data == void 0 || data == null) {
      if (addFrontmatter) {
        this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter[metadataValue] = 0;
        });
      }
      data = "0";
    }
    return data;
  }
  getIfActivityIsDailyOrWeekly(metadataValue) {
    let returnValue = "";
    this.settings.activities.forEach((element) => {
      if (element.name == metadataValue) {
        returnValue = element.frequency;
        return;
      }
    });
    return returnValue;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    this.resetActivites();
    await this.saveData(this.settings);
  }
};
var Activity = class {
  constructor(name, emoji, max, startColor, endColor, frequency) {
    this.frequency = frequency;
    this.name = name;
    this.emoji = emoji;
    this.max = max;
    this.startColor = startColor;
    this.endColor = endColor;
  }
};
var DEFAULT_SETTINGS = {
  activities: [],
  hideWhenClosed: false,
  askForWeight: true,
  useWeekFile: false
};
var ActivityTrackerTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Hide numbers when button is closed?").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.hideWhenClosed).onChange(async (value) => {
        this.plugin.settings.hideWhenClosed = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Allow tasks to be worth multiple points?").setDesc("You will be given a prompt when attaching a task to a goal to input how many points it is worth").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.askForWeight).onChange(async (value) => {
        this.plugin.settings.askForWeight = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Monday note or weekly note for weekly goals?").setDesc("Decides whether to use the monday note or the weekly note (typically in the format eg.2024-W48) to store the data for weekly goals. Daily goals are always stored in the current daily note").addDropdown(
      (dropdown) => dropdown.addOption("monday", "Monday file").addOption("week", "Weekly file").setValue(this.plugin.settings.useWeekFile ? "week" : "monday").onChange(async (value) => {
        this.plugin.settings.useWeekFile = value == "monday" ? false : true;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Activities").setHeading();
    this.plugin.settings.activities.map((activity, index) => {
      new import_obsidian.Setting(containerEl).setName("Daily or weekly goal?").setDesc("Should this goal reset daily or weekly").addDropdown(
        (dropdown) => dropdown.addOption("weekly", "Weekly").addOption("daily", "Daily").setValue(activity.frequency).onChange(async (value) => {
          activity.frequency = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Frontmatter value").setDesc("Value in the file's frontmatter. Note changing this will not update the name in the frontmatter and instead just create a new property").addText(
        (text) => text.setPlaceholder("Insert name here").setValue(activity.name).onChange(async (value) => {
          activity.name = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Icon").setDesc("Icon used for the status bar button. I recommend using https://emojipedia.org/ to find icons").addText(
        (text) => text.setPlaceholder("Paste emoji here").setValue(activity.emoji).onChange(async (value) => {
          activity.emoji = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Goal").setDesc("Weekly goal for this activity").addText(
        (text) => text.setPlaceholder("Insert goal here").setValue(activity.max).onChange(async (value) => {
          activity.max = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Start color").setDesc("Starting color for the status bar gradient").addColorPicker(
        (color) => color.setValue(activity.startColor).onChange(async (value) => {
          activity.startColor = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("End color").setDesc("Ending color for the status bar gradient").addColorPicker(
        (color) => color.setValue(activity.endColor).onChange(async (value) => {
          activity.endColor = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).addButton(
        (el) => el.setButtonText("Remove activity").onClick(() => {
          this.plugin.settings.activities.splice(index, 1);
          this.display();
          this.plugin.saveSettings();
        })
      );
      if (index != 0) {
        new import_obsidian.Setting(containerEl).addButton(
          (el) => el.setButtonText("\u028C").onClick(() => {
            let temp = this.plugin.settings.activities[index];
            this.plugin.settings.activities[index] = this.plugin.settings.activities[index - 1];
            this.plugin.settings.activities[index - 1] = temp;
            this.display();
            this.plugin.saveSettings();
          })
        );
      }
      if (index != this.plugin.settings.activities.length - 1) {
        new import_obsidian.Setting(containerEl).addButton(
          (el) => el.setButtonText("v").onClick(() => {
            let temp = this.plugin.settings.activities[index];
            this.plugin.settings.activities[index] = this.plugin.settings.activities[index + 1];
            this.plugin.settings.activities[index + 1] = temp;
            this.display();
            this.plugin.saveSettings();
          })
        );
      }
    });
    new import_obsidian.Setting(containerEl).addButton(
      (el) => el.setButtonText("Add new activity").onClick(() => {
        let newActivity = {
          frequency: "weekly",
          name: `newgoal${this.plugin.settings.activities.length + 1}`,
          emoji: "\u2728",
          max: "10",
          startColor: "#FFFFFF",
          endColor: "#FFFFFF"
        };
        this.plugin.settings.activities.push(newActivity);
        this.display();
        this.plugin.saveSettings();
      })
    );
  }
};
var InputModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    let weight = 1;
    this.setTitle(`${weight} points`);
    new import_obsidian.Setting(this.contentEl).setName("How many points should this task be worth?").addButton(
      (btn) => btn.setButtonText("+").setCta().setClass("modalButton").onClick(() => {
        weight++;
        this.setTitle(`${weight} points`);
      })
    ).addButton(
      (btn) => btn.setButtonText("-").setCta().setClass("modalButton").onClick(() => {
        weight--;
        this.setTitle(`${weight} points`);
      })
    ).addButton(
      (btn) => btn.setButtonText("Submit").setCta().setClass("submitButton").onClick(() => {
        this.close();
        onSubmit(`${weight}`);
      })
    );
  }
};


/* nosourcemap */