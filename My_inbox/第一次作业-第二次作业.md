整体来说做的比较好，TASK2完成度要比TASK1完成度差一些，问题也主要集中在TASK2上。
S2：有分组之后，按照从高到底顺序画了dist；有的只写了值，但没有画图；还有画的线装图的。多排了一下的我没扣分，少做了的我扣了分。
S7&S8：花样比较多，但总体来说大家都把数给算出来了。
S9：很多同学做出来的方法不如答案简洁，而是用新建dataframe的形式来做的。
S10：很多人不懂什么意思，有的不是按年份来做的，我一律没给分。

整体来说做的比较好，TASK2完成度要比TASK1完成度差一些，问题也主要集中在TASK2上。
S2：有分组之后，按照从高到底顺序画了dist；有的只写了值，但没有画图；还有画的线装图的。多排了一下的我没扣分，少做了的我扣了分。
S7&S8：花样比较多，但总体来说大家都把数给算出来了。
S9：很多同学做出来的方法不如答案简洁，而是用新建dataframe的形式来做的。
S10：有少数不懂题目啥意思，还有的不是按年份来做的，我一律没给分。





s7-s8做的花样比较多

s2 dist有要求做bar么？

虽然这两段代码的最终效果（筛选出2008年的数据）相似，但第一段代码通过索引来实现筛选，更加快速且代码简洁，适合于频繁进行基于日期的查询操作。第二段代码则在数据框的结构不变的情况下进行筛选，适用于不需要或不想改变数据框索引结构的情况。选择哪种方法取决于具体的应用场景和个人或项目的需求。

groupby(df['Closing Date'].dt.year) 很多人这样子搞


S2:
画蛇添足，按从高到底排序了

还有只差一步没画图的



T1-S9 这个表达不太行


我第一遍改的时候，主要是从看代码，代码一致的，就没啥问题。代码不一致的，我会看下这个具体用法，当时我主要是从语义的角度判分了，这回我run一下判分。

这次作业，大多数同学做的都还挺不错的，代码不一致的集中在
Task1-S9 一些同学print的没带字符串 但是值是正确的，我给判对了.
Task2-S4 大家各显神通，有用循环的，也有用apply的，还有匿名函数的，结果没问题
Task2-S5 计算上大多以计算百分比为主，没想到用mean就也可以

摘要稍微有点短了
可以加个政策贡献
假设一可以换成H1或者假设1


理论贡献
政策建议是最后一栏